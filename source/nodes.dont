module nodes;

import std.sumtype;
import std.traits: getSymbolsByUDA;
import std.array: array;
import std.algorithm;
import pegged.grammar : ParseTree;

import std.stdio;

struct Module {
    Statement[] statements;

    this(ParseTree tree) {
        validate_node!"File"(tree);
        validate_node!"Statement_list"(tree.children[0]);
        this.statements = tree.children[0]
            .map!(a => Statement.create(a))
            .array;
    }
}

interface Statement {
    alias Types = getSymbolsByUDA!(typeof(this), "Statement");

    static typeof(this) 
    create(ParseTree tree) {
        validate_node!"Statement"(tree);
        assert(tree.children.length == 1);

        ParseTree node = tree.children[0];
        switch (node_name(node)) {
            static foreach(Type; Types) {
                case Type.node_name:
                    return Type.create(node);
            }
            default: 
                assert(0);
        }
    }

    @"Statement":
    class Declare_variable: Statement {
        enum node_name = "Declare_variable";
        string name;
        Ref!Type_expression type = new Type();
        Ref!Expression      init = new get_children!Expression[0]();

        static typeof(this) 
        create(ParseTree tree) {
            validate_node!"Declare_variable"(tree);
            assert(tree.children.length == 2);
            type = Type_expression.create(tree.children[0]);
            init = Expression.create(tree.children[1]);
        }
    }
    class Declare_function: Statement {
        enum node_name = "Declare_function";
        this(ParseTree node) {
            writeln(node_name);
        }
    }

}



@"Aggregate_parameter":
interface Type_expression : Aggregate_parameter {
    enum node_name = "Type_expression";
    alias Types = getSymbolsByUDA!(typeof(this), "Type_expression");
    
    static typeof(this) 
    create(ParseTree tree) {
        writeln(node_name, " is not implemented");
    }

}

    // @"Type_expression":
class Name : Type_expression {string name;}
class Union_xor : Type_expression {
    Ref!Aggregate_parameter[] members;
}
class Union_or : Type_expression {
    Ref!Aggregate_parameter[] members;
}
class Struct_and : Type_expression {
    Ref!Aggregate_parameter[] members;
}
class Array : Type_expression {}
class Pointer : Type_expression {}

interface Aggregate_parameter {
    static typeof(this) 
    create(ParseTree tree) {
        writeln(node_name, " is not implemented");
    }
}

class Parameter {
    string name;
    string type;
}

@"Statement"
interface Expression : Statement {
    enum node_name = "Expression";

    static typeof(this) 
    create(ParseTree tree) {
        writeln(node_name, " is not implemented");
    }

    @"value":
    class Name {}
}


// alias get_types = getSymbolsByUDA(typeof(this))


struct Ref(T) {
    static if (is(T == class) || is(T == interface)) {
        alias Ref_type = T;
    } else {
        alias Ref_type = T*;
    } 
    
    Ref_type value;


    this(Ref_type value_) {
        assert(value_ != null);
        this.value = value_;
    }

    ref T get() {
        static if (is(T == class)) {
            assert(value != null);
            return value;
        } else {
            return *value;
        }
    }

    alias get this;
}


void validate_node(string name)(ParseTree tree) {
    assert(node_name(tree) == name);
}
string node_name(ParseTree tree) {
    import std.array: split;
    return tree.name.split!('.')[1];
}


import std.meta;
template get_children(T, string module_ = __MODULE__) {
    alias get_children = AliasSeq!();
    static foreach (s; __traits(allMembers, mixin(module_))) {
        static if (__traits(compiles, (){mixin(s, " value");}()) 
        && is(mixin(s) : T) && !is(mixin(s) == T)) {
            get_children = AliasSeq!(all_types, mixin(s));
        }
    }
}
